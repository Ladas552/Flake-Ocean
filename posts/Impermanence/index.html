<!doctypehtml><html lang=en-US><meta charset=UTF-8><meta content=width=device-width,initial-scale=1.0 name=viewport><meta content=Norgolith name=generator><meta content="Guide for my impermanence setup"name=description><meta content=[ladas552] name=author><meta content=Nix name=keywords><meta content="Impermanence On Nixos With Zfs And Tmpfs - Nix"property=og:title><meta content=article property=og:type><meta content=https://ladas552.me/Flake-Ocean/posts/Impermanence/ property=og:url><meta content="Guide for my impermanence setup"property=og:description><meta content=Nix property=og:site_name><meta content=en-US property=og:locale><link href=https://ladas552.me/Flake-Ocean/posts/Impermanence/ rel=canonical><meta content="index, follow"name=robots><link href=https://prismjs.catppuccin.com/mocha.css rel=stylesheet><script defer src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js></script><script defer src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js></script><script defer src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/@alpinejs/collapse@3.x.x/dist/cdn.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js></script><script>document.addEventListener(`alpine:init`,()=>{let b=`theme`,c=`light`,d=`dark`,a=`sidebarCollapsed`;Alpine.data(`menu`,()=>({currentPage:window.location.pathname,openMobile:!1,sidebarCollapsed:localStorage.getItem(a)===`true`,toggleMobile(){this.openMobile=!this.openMobile},toggleSidebar(){this.sidebarCollapsed=!this.sidebarCollapsed;localStorage.setItem(a,this.sidebarCollapsed)}}));Alpine.data(b,()=>({current:c,init(){const a=localStorage.getItem(b);if(a){this.current=a}else if(window.matchMedia(`(prefers-color-scheme: dark)`).matches){this.current=d};localStorage.setItem(b,this.current);if(this.current===d){document.documentElement.classList.add(d)}},toggle(a){const e=a.clientX;const f=a.clientY;document.documentElement.style.setProperty(`--x`,`${e}px`);document.documentElement.style.setProperty(`--y`,`${f}px`);if(!document.startViewTransition){this.current=this.current===d?c:d;document.documentElement.classList.toggle(d,this.current===d);localStorage.setItem(b,this.current);return};const g=document.startViewTransition(()=>{this.current=this.current===d?c:d;document.documentElement.classList.toggle(d,this.current===d);localStorage.setItem(b,this.current)})}}))})</script><script defer src=https://cdnjs.cloudflare.com/ajax/libs/mermaid/11.9.0/mermaid.min.js></script><link href=https://ladas552.me/Flake-Ocean/assets/css/styles.min.css rel=stylesheet><link href=/assets/favicon.png rel=icon><title>Impermanence On Nixos With Zfs And Tmpfs - Nix</title><body x-data=menu><header><nav class="flex items-center h-full px-4"><button aria-label="Toggle Menu"class="menu-btn md:hidden"@click=toggleMobile><svg viewbox="0 0 24 24"fill=none stroke=currentColor x-show=!openMobile><path d="M4 6h16M4 12h16M4 18h16"stroke-linecap=round stroke-linejoin=round stroke-width=2 /></svg> <svg viewbox="0 0 24 24"fill=none stroke=currentColor x-show=openMobile><path d="M6 18L18 6M6 6l12 12"stroke-linecap=round stroke-linejoin=round stroke-width=2 /></svg></button><a class=header-title href=https://ladas552.me/Flake-Ocean/>Nix</a><div class="hidden md:flex md:items-center md:gap-6 md:ml-8"><a :class="{ 'active-nav': currentPage.startsWith('/categories') }"class=nav-link href=https://ladas552.me/Flake-Ocean/categories>Tags</a></div><div x-data=theme><button :aria-label="current === 'dark' ? 'Switch to light mode' : 'Switch to dark mode'"@click=toggle($event) class=theme-toggle><svg viewbox="0 0 24 24"x-show="current === 'dark'"fill=none stroke=currentColor><path d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z"stroke-linecap=round stroke-linejoin=round stroke-width=2 /></svg> <svg viewbox="0 0 24 24"x-show="current === 'light'"fill=none stroke=currentColor><path d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z"stroke-linecap=round stroke-linejoin=round stroke-width=2 /></svg></button></div></nav></header><div class=page-wrapper><aside :class="{ 'open': openMobile, 'collapsed': sidebarCollapsed }"class=sidebar><button :aria-label="sidebarCollapsed ? 'Expand sidebar' : 'Collapse sidebar'"class="sidebar-toggle hidden md:flex"@click=toggleSidebar><svg viewbox="0 0 24 24"fill=none stroke=currentColor x-show=!sidebarCollapsed><path d="M11 19l-7-7 7-7m8 14l-7-7 7-7"stroke-linecap=round stroke-linejoin=round stroke-width=2 /></svg> <svg viewbox="0 0 24 24"fill=none stroke=currentColor x-show=sidebarCollapsed><path d="M13 5l7 7-7 7M5 5l7 7-7 7"stroke-linecap=round stroke-linejoin=round stroke-width=2 /></svg></button><nav><div class=nav-section><h3>Documentation</h3><a :class="{ 'active': currentPage === 'https://ladas552.me/Flake-Ocean/posts/Impermanence/' }"title="Guide for my impermanence setup"href=https://ladas552.me/Flake-Ocean/posts/Impermanence/>Impermanence on NixOS with ZFS and tmpfs</a></div></nav></aside><div :class="{ 'sidebar-collapsed': sidebarCollapsed }"class=content-wrapper><main class=content><h1>Impermanence on NixOS with ZFS and tmpfs</h1><p class=post-meta><time datetime=2026-01-02>January 2, 2026</time> <span class=tag-spacing> Tags: <a href=https://ladas552.me/Flake-Ocean/categories/Nix>Nix</a> </span><h2 id=What-is-Impermanence>What is Impermanence</h2><hr><p>It wipes your <code>/root</code> on reboot and your startup is a blank canvas, but you can persist mounts and bind mount directories from it in your normal root to save stuff like cache and tokens. So you wipe all the junk and save actually useful stuff.<p>For example you can install full KDE Plasma session, run it, and if you get bored. Just disable it and no KDE junk left.<p><strong>Important to note</strong>: That impermanence of my setup uses tmpfs, so it writes <code>/root</code> to RAM, so nothing actually gets erased on the Disk. Meaning no continuous I/O rewrites wearing out your Drive(<em>not that it would mater in practice</em>). But the state isn't saved between reboots, as with anything on RAM<p>Also when I refer to <code>/root</code>, it's actually the whole <code>/</code>, not just root user directory.<h3 id=Why-did-you-set-it-up>Why did you set it up</h3><hr><p>I was bored. I don't find benefits of impermanence so crucial to completely overhaul how your system behaves and I don't trust myself to maintain it.<p>But there are some benefits to it:<ul><li>I only backup important files, no cache, no states, only files and media;</ul><ul><li>I always know what's on my system because it's declared in the config;</ul><ul><li>It opens up possibilities to experiment more with my system, because if I could setup impermanence and not loose all my files, I am unstoppable;</ul><h3 id=What's-the-meaning-of-writing-this-page?>What's the meaning of writing this page?</h3><hr><p>It's not that hard to setup impermanence, but to requires reading a lot of stuff, and if you don't use ZFS or BTRFS even full reinstall for rearranging partitions. I have read several articles, watched videos, and stole code from many GitHub repos.<p>Plus most guides just go to the wipe stage right away, without saying how to persist, or how it practically works for the user to not loose their files. I will try to compete in these aspects.<h3 id=What-is-your-current-setup?>What is your current setup?</h3><hr><p>I got ZFS with tmpfs, with 2 persistence datasets. <code>/cache</code> and <code>/persist</code>. And a plaint vFAT <code>/boot</code> partition, where GRUB or Systemd-boot will put generation images.<p>Most people assume you gotta have 64Gb or RAM for tmpfs to be convenient, but actually you just need a well structured disk layout. Then the tmpfs usually only takes 50MB to 100MB of RAM.<p>Template structure of ZFS datasets that will be essential:<ul><li><code>/cache</code> is for rust targets, everything in <code>~/.cache</code>, .local states, etc.</ul><ul><li><code>/persist</code> is for Media, browser profiles, Projects, etc. This is the only datasets that get's backed up by <code>sanoid</code>.</ul><ul><li><code>/nix</code> for /nix/store. NixOS won't boot without it. All the files that aren't persisted, but appear on my system are symlinked from <code>/nix</code>. That includes config files and services.</ul><ul><li><code>/tmp</code> for /tmp. yeah, anyways it's to not overload tmpfs when downloading something on browser. with <code>boot.tmp.cleanOnBoot = true;</code> it is cleared on boot anyways.</ul><p>tmpfs is erased on reboot, so <code>/</code> and everything below it, including <code>/home</code> is gone, unless put into <code>/cache</code> or <code>/persist</code> datasets. tmpfs is on RAM, so it can overload if exceeds certain size, to prevent that I got several more zfs datasets, that aren't persisted, meaning they don't have connection to files in other datasets, but aren't erased by default.<h2 id=What-we-need?>What we need?</h2><h3 id=A-ZFS-setup>A ZFS setup</h3><p>This isn't a <strong>ZFS guide</strong> so, unless you have <strong>ZFS setup</strong> on your <strong>NixOS</strong>, you can kiss this Guide goodbye. Go read OpenZFS documentation. But here is my installation script in case you'd like more guiding. But seriously, go read docs, real engineers know a lot more than I do.<p><a href=https://github.com/Ladas552/Flake-Ocean/blob/e460837d18f37723510f9b74c46636fd2b5b4f25/install/impermanence.norg>permalink in the github repo, please insure the branch is up to date before checking in</a>, it contains actual descriptions to each line as a Norg file format that you can tangle. Like bible in org mode.<pre><code class=language-sh>sudo zpool create -f \
-o ashift=12 \
-o autotrim=on \
-O compression=zstd \
-O acltype=posixacl \
-O atime=off \
-O xattr=sa \
-O normalization=formD \
-O mountpoint=none \
zroot "/dev/sda2"

sudo zfs create -o mountpoint=legacy zroot/root
sudo mount -t zfs zroot/root /mnt

sudo mount --mkdir "$BOOTDISK" /mnt/boot
# All the stuff below will be explained later
sudo zfs create -o mountpoint=legacy zroot/nix
sudo mount --mkdir -t zfs zroot/nix /mnt/nix

sudo zfs create -o mountpoint=legacy zroot/tmp
sudo mount --mkdir -t zfs zroot/tmp /mnt/tmp

sudo zfs create -o mountpoint=legacy zroot/cache
sudo mount --mkdir -t zfs zroot/cache /mnt/cache

sudo zfs create -o mountpoint=legacy zroot/persist
sudo zfs snapshot zroot/persist@blank
sudo mount --mkdir -t zfs zroot/persist /mnt/persist
# All the stuff above will be explained later
sudo nixos-install --no-root-password --flake "github:Ladas552/Nix-Is-Unbreakable#NixVM"
</code></pre><h3 id=Partitions>Partitions</h3><hr><p>A new way to manage your system. NixOS.<p>Tho you probably already use NixOS if you are reading this, if you don't then get out while you can.<p>On a more serious note, you need ZFS setup, with 2 particular datasets.<pre><code class=language-nix>fileSystems = {
  "/nix" = {
    device = "zroot/nix";
    fsType = "zfs";
  };
  "/tmp" = {
    device = "zroot/tmp";
    fsType = "zfs";
  };
};
</code></pre><p>If you don't have them, but have ZFS installed, just create them using commands<pre><code class=language-sh>sudo zfs create -o mountpoint=legacy zroot/tmp
sudo zfs create -o mountpoint=legacy zroot/nix
</code></pre><p>This will insure that you won't delete your <code>/nix/store</code> and it stays intact between reboots. And for this particular setup the <code>tmp</code> dataset will be used so our <code>tmpfs</code> <strong>root</strong> will insure that it won't randomly overload.<h3 id=Impermanence-module>Impermanence module</h3><hr><p>The <a href=https://github.com/nix-community/impermanence>Impermanence module</a> is a NixOS flake that creates <code>mount binds</code>. The main purpose of it is to just put stuff in special <code>/persist</code> dataset, and still be able to access it from <code>/root</code> and <code>/home</code>. More about technicality of bind mounts later<p>Basically you define certain directories names in it, and it creates them, then binds them to specific relevant locations, like <code>".config/nvim"</code> will be located in <code>~/.config/nvim</code>. And if you put your Neovim config there, neovim will still follow the config, but it will be located on different dataset, and won't be wiped on boot.<p>Neat right? Not really, because if directory already exists, Impermanence will override that old directory with new empty one. <strong>Don't panic</strong>. Data isn't lost, it was just reallocated, you can delete the directory from impermanence module and it will comeback.<p>That's the main reason why most people reinstall their OS if they want to use Impermanence, because it's a pain in the glands to move the files from directories before persisting it and moving things back. There are projects that circumvent that, but I didn't use them. For example: <a href=https://github.com/Geometer1729/persist-retro>Persist-retro</a>.<p>Also to persist an individual file, you need to move the file, and manually copy it to persist directory. Otherwise it complains about the original file being in the way of a mount bind.<h4 id=You-forgot-to-tell-installation-instructions>You forgot to tell installation instructions</h4><hr><p>It's nix so here is just a snippet of code. Works for flakes.<pre><code class=language-nix>#flake.nix
{
  inputs.impermanence.url = "github:nix-community/impermanence";
}
</code></pre><p>And then just import the module, like:<pre><code class=language-nix>imports = [
  inputs.impermanence.nixosModules.impermanence
];
</code></pre><p>We will only use the <code>nixosModule</code> because I don't have standalone Home-Manager and not planning to adopt impermanence for distros outside of NixOS.<p>I have seen people use impermanence module on non flake setups, but I am not so interested in them to find and link a good one.<h3 id=Immutable-users>Immutable users</h3><hr><p>As we delete everything in <code>/root</code>, it means passwords for users, and most importantly <code>root</code> user will be deleted.<p>So just make them immutable. You can store the password file in sops, or just provide raw path from <code>/persist</code> directory.<pre><code class=language-nix>{
  # setup immutable users for impermanence

  # silence warning about setting multiple user password options
  # https://github.com/NixOS/nixpkgs/pull/287506#issuecomment-1950958990
  # Stolen from Iynaix https://github.com/iynaix/dotfiles/blob/4880969e7797451f4adc3475cf33f33cc3ceb86e/nixos/users.nix#L18-L24
  options = {
    warnings = lib.mkOption {
      apply = lib.filter (
        w: !(lib.hasInfix "If multiple of these password options are set at the same time" w)
      );
    };
  };

  config = {
    # disabling user mutability
    users.mutableUsers = false;

    # defining regular user, ME!
    users.users.ladas552 = {
      isNormalUser = true;
      description = "Ladas552";
      extraGroups = [
        "networkmanager"
        "wheel"
      ];
      initialPassword = "pass";
      # Use a path or your  encryption method here
      hashedPasswordFile = config.sops.secrets."mystuff/host_pwd".path;
    };

    nix.settings.trusted-users = [ "ladas552" ];

    # Setting root user
    users.users.root = {
      initialPassword = "pass";
      hashedPasswordFile = config.sops.secrets."mystuff/host_pwd".path;
    };
  };
}
</code></pre><p>Other features for immutable users:<ul><li>Can use <code>--no-root-password</code> flag in <code>nixos-install</code> command. Meaning you don't ever have to monitor it, it will install password automatically.</ul><ul><li>Can't use <code>passwd &LTuser></code> command. So if you mess up your password path the first time, you have to reboot to previous generation to set it correctly.</ul><p>The <code>initialPassword</code> is set as plain text because it suppose to be a backup if sops decryption failed, so you won't leave with useless system state. Otherwise, it's unused and won't have security implications for your host.<h3 id=When-do-we-start-deleting-stuff?>When do we start deleting stuff?</h3><hr><p>Not so fast bakaru, we first need to save our stuff.<p>So you need to create persisted directories<pre><code class=language-sh>sudo zfs create -o mountpoint=legacy zroot/persist
sudo zfs create -o mountpoint=legacy zroot/cache
</code></pre><p>And now we add them to be mounted on boot<pre><code class=language-nix># persist mount
fileSystems."/persist" = {
  device = "zroot/persist";
  fsType = "zfs";
  # so it's required to boot, and you won't reboot into empty desktop
  neededForBoot = true;
};

# cache are files that should be persisted, but not to snapshot
# e.g. npm, cargo cache etc, that could always be redownload
"/cache" = {
  device = "zroot/cache";
  fsType = "zfs";
  neededForBoot = true;
};
</code></pre><p>I also recommend setting up backups with sanoid if you didn't already.<pre><code class=language-nix>services.sanoid = {
  enable = true;
  # if you have sanoid options somewhere else, lib.mkForce
  # will override anything, so you only have snapshots that matter
  datasets = lib.mkForce {
    "zroot/persist" = {
      hourly = 50;
      daily = 15;
      weekly = 3;
      monthly = 1;
    };
  };
};
</code></pre><p>Now we have basic datasets that will store out stuff, Impermanence can wait now, we need to assign bind mounts for directories and files!<p>Don't know what bind mounts are? Well simply put. They are mounts that make some directory to appear in normal location, but actually it's in a different dataset all together.<p>So for example: <code>/home/alice225/Downloads</code> will be deleted on boot. But, not it's content. On the next boot, the content of <code>Downloads</code> that is in <code>/persist</code> dataset will remount itself to <code>/home/alice225/Downloads</code> path.<p>It will appear seamless to other applications and to yourself. But now you can access the same files in both <code>/home/alice225/Downloads</code> and in <code>/persist/home/alice225/Downloads</code>. And remember, it is <strong>not a symlink</strong>. Symlinks fool programs, while bind mounts genuinely make files accessible in several locations. But be careful, because they share permissions, and can also be deleted.<h3 id=Okay,-we-have-locations,-let's-move-some-files-into-them>Okay, we have locations, let's move some files into them</h3><hr><p>So, with Impermanence module, there are some options available. Simplest approach would be to use it directly<pre><code class=language-nix>environment.persistence = {
  # one of out datasets
  "/persist" = {
    # useful option
    hideMounts = true;
    directories = [
      # absolute path to directories in string values
      "/var/log"
      "/var/lib/nixos"
      "/etc/NetworkManager/"
    ];
  };
};
</code></pre><p>Now you are able to just define your paths as normal and save them. But this is just normal impermanence, This blog post is about <strong>My</strong> setup specifically, so how about we add some abstractions to the vanilla scheme.<h4 id=New-options>New options</h4><hr><p><code>directories</code> and <code>files</code> in impermanence module are just a list of string, so we can make pseudo options to add more strings to the list and <code>++</code> them with actual persistence option, or just reference our list.<p>It will make it easier to define directories under different scopes. For example, setting files in <code>home.nix</code> file, but they will be used in <code>configuration.nix</code> file.<pre><code class=language-nix>{lib,...}:
{
  options = {
    # options to put directories in, persistence but shortened
    # stolen from @iynaix
    root = {
      directories = lib.mkOption {
        type = lib.types.listOf lib.types.str;
        default = [ ];
        description = "Directories to persist in root filesystem";
      };
      files = lib.mkOption {
        type = lib.types.listOf lib.types.str;
        default = [ ];
        description = "Files to persist in root filesystem";
      };
      cache = {
        directories = lib.mkOption {
          type = lib.types.listOf lib.types.str;
          default = [ ];
          description = "Directories to persist, but not to snapshot";
        };
        files = lib.mkOption {
          type = lib.types.listOf lib.types.str;
          default = [ ];
          description = "Files to persist, but not to snapshot";
        };
      };
    };
    home = {
      directories = lib.mkOption {
        type = lib.types.listOf lib.types.str;
        default = [ ];
        description = "Directories to persist in home directory";
      };
      files = lib.mkOption {
        type = lib.types.listOf lib.types.str;
        default = [ ];
        description = "Files to persist in home directory";
      };
      cache = {
        directories = lib.mkOption {
          type = lib.types.listOf lib.types.str;
          default = [ ];
          description = "Directories to persist, but not to snapshot";
        };
        files = lib.mkOption {
          type = lib.types.listOf lib.types.str;
          default = [ ];
          description = "Files to persist, but not to snapshot";
        };
      };
    };
  };
}
# Holy cow nix is indented to all suns
</code></pre><p>You can add more options if need be. In this we only define lists for <code>/persist</code> and <code>/cache</code>, but they are separated into <code>root</code> and <code>home</code>. So add <code>root</code> and <code>home</code> options to <code>nixocConfiguration</code> and add only <code>home</code> to home-manager for example.<p><code>home</code> is just a simple way to separate directories in <code>/home/ladas552</code> from just <code>/</code>.<p>But, you know, I use flake-parts and I don't need to add these options to different files and scope. I can just inherit them all in one file!<pre><code class=language-nix>{ lib, ... }:
# link to snippet in my config
# https://github.com/Ladas552/Flake-Ocean/blob/85ee207aa2e5e0d2e44aad0a0818a533ceca72cf/modules/nixosModules/Impermanence/imp-options.nix
{
  flake.modules =
    let
      # options to put directories in, persistence but shortened
      # stolen from @iynaix

      root = {};
      home = {};
      # Same thing as above
    in
      {
      nixos.options.options.custom.imp = { inherit root home; };
      hjem.options.options.custom.imp = { inherit home; };
      homeManager.options.options.custom.imp = { inherit home; };
    };
}
</code></pre><p>This code block is from my Dendrithic config with several module classes. So each <code>nixos</code>, <code>hjem</code> and <code>homeManager</code> classes have their own <code>options</code> module that inherit the same type of options in each module scope.<p>You probably didn't get any of that, but you don't need to tbh. My setup is My setup, do whatever you want.<h4 id=Persist-in-action>Persist in action</h4><hr><p>Now we can define some important directories and files to persist<pre><code class=language-nix>custom.imp = {
  root = {
    directories = [
      "/etc/NetworkManager/"
      "/var/lib/NetworkManager"
      "/var/lib/iwd"
    ];
  };
  home = {
    directories = [
      ".librewolf"
    ];
    cache = {
      files = [ ".local/share/com.jeffser.Alpaca/alpaca.db" ];
      directories = [
        ".local/share/nvim"
        ".local/state/nvim"
        ".config/libreoffice"
        ".cache/librewolf"
        ".cache/keepassxc"
        ".config/keepassxc"
        ".cache/nix"
        ".cache/nix-index"
      ];
    };
  };
};
</code></pre><p>But if you set this thing up, and rebuild it wouldn't do a thing. Remember, these options and list are just place holders. Meant to be easy to write and read. Now we gotta add them to an actual Impermanence module options.<pre><code class=language-nix>{ lib, config, ... }:
let
  cfg = config.custom.imp;
  # config.custom.meta.user is just my placeholder for `username`
  # just hard code the value, or replace it with your own solution to select a user
  cfghm = config.home-manager.users."${config.custom.meta.user}".custom.imp;
  cfghj = config.hjem.users."${config.custom.meta.user}".custom.imp;
in
  {
  environment.persistence = {
    "/persist" = {
      hideMounts = true;
      # referencing files via our abstraction option
      files = lib.unique cfg.root.files;
      directories = lib.unique (
        # here you can define directories normally 
        [
          "/var/log"
          "/var/lib/nixos"
        ]
        # and concatenate too!
        ++ cfg.root.directories
      );
      # add persists to `/home/user` path
      users."${config.custom.meta.user}" = {
        files = lib.unique ([ ] ++ cfghm.home.files ++ cfghj.home.files);
        directories = lib.unique (
          [ ] ++ cfg.home.directories ++ cfghm.home.directories ++ cfghj.home.directories
        );
      };
    };
    # same as above
    "/cache" = {
      hideMounts = true;
      files = lib.unique cfg.root.cache.files;
      directories = lib.unique cfg.root.cache.directories;
      users."${config.custom.meta.user}" = {
        files = lib.unique (cfg.home.cache.files ++ cfghm.home.cache.files ++ cfghj.home.cache.files);
        directories = lib.unique (
          cfg.home.cache.directories ++ cfghm.home.cache.directories ++ cfghj.home.cache.directories
        );
      };
    };
  };
}
</code></pre><p>You will need to adjust this code snippets to your own config. For example, if you don't use <code>hjem</code>. And replace <code>config.custom.meta.user</code> with your own username.<p>I am not stating this approach is the best, but it just how I ended up using Impermanence module, and it might be useful for you to know.<p>Now upon rebuild Impermanence module should add all the interesting directories to datasets and establish bind mounts.<p>Wait, did we forget something? Uhhh...<h3 id=DELETE-ERASE-REDUCTED>DELETE ERASE REDUCTED</h3><hr><pre><code class=language-nix># replace the root mount with tmpfs
# wipes everything if you don't have proper persists, be warned
fileSystems."/" = lib.mkForce {
  device = "tmpfs";
  fsType = "tmpfs";
  neededForBoot = true;
  options = [
    "defaults"
    # whatever size feels comfortable, smaller is better
    "size=1G"
    "mode=755"
  ];
};
</code></pre><p>This is all you need. So simple in comparison to the whole page above, right?<p>The main reasons for that are:<ul><li>It's harder to keep what you have gained, but trivial to loose everything you ever had;</ul><ul><li>Also the <code>size=1G</code> wouldn't make it possible to use tmpfs as a main without persists and bind mounts. Bind mount only makes files accessible in 2 locations, but only stored in ZFS dataset.</ul><p>This should be all you need to start using tmpfs for impermanence on ZFS.<p>There are some niceties I want to share tho, to make your life easier.<h3 id=Some-sprinkles-to-your-epitome-of-agony>Some sprinkles to your epitome of agony</h3><h4 id=Snippets>Snippets</h4><hr><p>Set this so you aren't lectured by <code>you know what you are doing</code> lecture from sudo every boot<pre><code class=language-nix>security.sudo.extraConfig = "Defaults lecture=never";
</code></pre><p>If you use <a href=https://github.com/Mic92/sops-nix>sops-nix</a>, set ssh paths to <code>/persist</code> because otherwise <code>nixos-install</code> won't find the keys.<pre><code class=language-nix>sops.age.sshKeyPaths = [
  "/persist/home/vimjoyer/.ssh/ssh-key"
];
sops.age.keyFile = lib.mkDefault "/persist/home/vimoyer/.config/sops/age/keys.txt";
</code></pre><h4 id=Persist-everything>Persist everything</h4><hr><p>Persist every bit that might be useful to you, tokens, cookies and all that if they matter to you. Depending on the application, you might wanna persist only one file. But for something like steam, it compiles shader cache, which is persistable with this snippet<pre><code class=language-nix># persist steam
custom.imp.home = {
  cache.directories = [
    ".local/share/Steam"
    ".cache/mesa_shader_cache"
    ".cache/mesa_shader_cache_db"
    ".cache/radv_builtin_shaders"
  ];
};
</code></pre><p>But how would you know what to persist? Well, first you might want to look at others people config files. Because the best way to avoid pit falls is following the walked road.<p>Some pretty extended persist list can be found in following configurations:<ul><li><a href=https://github.com/search?q=repo%3Aiynaix%2Fdotfiles+custom.persist&type=code>Iynaix dotfiles</a>;</ul><ul><li><a href=https://github.com/saygo-png/nixos>Saygo's config</a>;</ul><ul><li><a href=https://github.com/xarvex/dotfyls>Xarvex dotfyls</a>;</ul><p>If they don't use the same modules as you, figure it out on your own. Most of the time programs follow xdg conventions and store files in <code>.config .cache .local/state .local/share</code>. Or instead of persisting the settings, symlink raw files.<h4 id=Credits-and-suggestions>Credits and suggestions</h4><hr><p>You can suggest anything you'd like to add to <a href=#Some-sprinkles-to-your-epitome-of-agony>Some sprinkles to your epitome of agony</a>. Cool configs using impermanence, tips, snippets and so on. Just ping me on Discord or write an issue on github. Your username will be added below as a privilege for being so awesome!<p>List of awesome people:<ul><li><strong>Iynaix</strong>'s impermanence abstraction structure and ZFS setup</ul><ul><li><strong>Vimjoyer</strong>'s Impermanence video introducing basic concept to me</ul><ul><li><strong>talyz</strong> for making Impermanence module and extensive readme for the project</ul><ul><li><strong>Graham</strong> for <a href=https://grahamc.com/blog/erase-your-darlings/>https://grahamc.com/blog/erase-your-darlings/</a></ul><ul><li><strong>Willbush</strong> for <a href=https://willbush.dev/blog/impermanent-nixos/>https://willbush.dev/blog/impermanent-nixos/</a></ul><ul><li><strong>Elis Hirwing</strong> for <a href=https://elis.nu/blog/2020/05/nixos-tmpfs-as-root/>https://elis.nu/blog/2020/05/nixos-tmpfs-as-root/</a></ul><ul><li><a href=https://github.com/fliplus>Flipus</a> and <strong>snohater</strong> for providing feedback on readability of the thing.</ul><ul><li><strong>You</strong> for reading this all, good luck with your NixOS config. Hope this article helped you the same way all the people mentioned above helped me. Without such a vast community, I wouldn't be able to figure all these things out. And I didn't reinvent a wheel, it's all the work of Open Source contributors. So, hopefully you also share your knowledge in the future. Improve on what's old or reduce it to atoms, it's up to you. It's your setup, and only for you to decide, whether you really want to setup it up.</ul></main><footer><div><p>ladas552 Â© 2026 | Licensed under GPLv3<p><a href=https://github.com/Ladas552/Flake-Ocean rel=noopener target=_blank>GitHub</a></div></footer></div></div>